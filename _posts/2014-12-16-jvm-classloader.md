#### 类与类加载器

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性。简单的说，如果要比较两个类是否相等，必须这个两个类是由同一个类加载器加载的前提之下才有意义。

这里说的相等是指 Class 对象的 equals()、isInstance()、isAssignableFrom() 方法的返回结果。

---
layout: post
title: Java 类加载器
categories: JVM
tags: 笔记 java
---

#### 双亲委派模型

Java 虚拟机角度只有两种类加载器：

- 启动类加载器，这个加载器使用 C++ 语言实现，是虚拟机的一部分。
- 另外的就是独立于虚拟机外部，并且继承自 java.lang.ClassLoader 。


从开发人员的角度还可以分的更细，有如下三种：

- 启动类加载器：这个加载器负责把 JAVA_HOME\lib 目录中，或者被 -Xbootclasspath 参数所指定的路径中，并且被虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用。
- 扩展类加载器：这个加载器负责加载 JAVA_HOME\lib\ext 目录，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可直接使用。
- 应用程序类加载器：这个类加载器是由 sun.misc.Launcher$AppClassLoader 来实现。由于这个类加载器是 ClassLoader 中 getSystemClassLoader() 方法的返回值，所以也被成为系统类加载器。它负责加载用户类路径(ClaasPath)上指定的类库，可以直接使用这个类加载器，一般这个就是程序中的默认类加载器。

#### 类加载器模型

![类加载器双亲委派模型](http://renchx.com/public/images/classloader-modle.jpg)

除了启动类加载器外，其他的加载器都应该有自己的父类加载器。这里面父子关系一般不使用继承，而使用组合方式实现。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先请求父类加载器去完成，每一个层次的加载器都是如此，因此所有请求都会传递到顶层的启动类加载器中，只有当父加载器返回自己无法完成这个加载请求时，子加载器才回自己去加载。

自己继承 ClassLoader 类只需要重写 findClass 方法即可，并且还可以保持双亲委派模型。


---EOF---
